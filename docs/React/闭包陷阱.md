# React 闭包陷阱

## 闭包陷阱的本质
在React中，由于JS的闭包机制+React的渲染机制，函数组件中回调函数和Effect会获取到过时的props和state，导致逻辑执行时仍在使用旧值

```js
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 这个Effect只在挂载时运行一次
    setTimeout(() => {
      console.log(count); // ❌ 永远打印0（闭包捕获了初始值）
    }, 1000);
  }, []); // 空依赖，count不会更新

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

解释：Effect在组件第一次渲染时就创建了闭包，捕获了当时的count值(0)，由于依赖数组为空，这个闭包永远不会被重新创建，timeout中看到的值永远为0

## 面试场景题
1. 定时器中的状态读取：
```js
// 问题：点击按钮3次后，1秒后应该显示3，但实际显示0
function TimerProblem() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setTimeout(() => {
      console.log('当前计数:', count); 
    }, 1000);
  }, []); // 缺少count依赖

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <p>计数: {count}</p>
    </div>
  );
}
```
解决方案：
```js
// 方案1：添加count到依赖数组
useEffect(() => {
  setTimeout(() => {
    console.log('当前计数:', count);
  }, 1000);
}, [count]); // 每次count变化重新创建定时器

// 方案2：使用函数式更新
useEffect(() => {
  setTimeout(() => {
    setCount(prev => {
      console.log('当前计数:', prev);
      return prev;
    });
  }, 1000);
}, []);

// 方案3：使用ref
const countRef = useRef(count);
useEffect(() => {
  countRef.current = count;
}, [count]);

useEffect(() => {
  setTimeout(() => {
    console.log('当前计数:', countRef.current);
  }, 1000);
}, []);
```

2. socket连接和主题更新
```js
// 问题：roomId变化时重连，但theme变化时不重连
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme); // theme变化时会重建连接
    });
    return () => connection.disconnect();
  }, [roomId, theme]); // 问题：theme变化也会触发Effect
}
```
useStaticEffectEvent解决方案：
```js
export const useStaticEffectEvent(callback) => {
  const callbackRef = useRef(callback);

  //每次渲染后更新ref
  useEffect(() => {
    callbackRef.current = callback;
  });

  //返回稳定引用的函数
  const eventFn = useCallback((...args) => {
    return callbackRef.current(...args);
  }, []);
  
  return eventFn;
}

function ChatRoom({ roomId, theme }) {
  const onConnected = useStaticEffectEvent(() => {
    showNotification('Connected!', theme); // 总是最新值
  });

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.on('connected', onConnected);
    return () => {
      connection.off('connected', onConnected);
      connection.disconnect();
    };
  }, [roomId, onConnected]); // onConnected是稳定的
}
```